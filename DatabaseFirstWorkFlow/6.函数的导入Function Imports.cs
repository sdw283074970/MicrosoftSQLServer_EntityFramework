//Q: 什么是函数导入？刚才函数不是跟随储存方法一起导入了吗？
//A: 函数确实跟随储存方法一起导入到EF中了，但是在实际情况中，我们可能会需要更改函数的名字来增加辨识度/方便调用，或者需要更改返回类型，这个时候，我们就
  //需要对函数的导入进行操作。

//Q: 操作的对象是什么？
//A: 我们说过数据库中的函数在SotrageModel中有直接体现，如果在导入时勾选了“同时导入进EF”那么也会在ConceptualModel中有C#可调用的版本，在Model浏览器，
  //即Model Browser中，通过双击ConceptualModel中的函数即可打开一个对话款对该函数进行编辑，实际上也是对“如何映射”经行编辑。在编辑选项中，我们有：

  //1.Function Import Name，即函数名，我们可以在这里更改该函数在ConceptualModel中的名称，即C#程序调用的名称，它会自动映射到选择的储存在StorageMOdel
    //中的函数；
  //2.Stored Procedure/Fucntion Name，即映射的原函数，选择即可以将我们正编辑的函数映射向选中的在StorageModel中的函数；
  //3.Returns a Collection of，即选择返回类型，可以选择四种返回类型，无返回类型、标量返回类型(如int、string)、复杂返回类型和实体(Entity)返回类型。

//Q: 什么是复杂类型？什么是实体类型？
//A:复杂返回类型其实是一种临时数据类型，随着储存过程/函数的导入自动生成，不会保存进数据库中，但我们可以对这些临时的表/列/对象进行操作，获取到我们想要的
  //部分。自动生成的复杂类型名称为函数名 + _Result，我们可以在Model浏览器中的ConceptualModel中的Complex Types查看。

  //实体类型即我们的表，我们可以通过返回实体类型来直接顶替(ConceptualModel中的)表中的原始数据。

//Q: 为什么要用复杂类型？
//A: 复杂类型，之前说了，等于说是临时表/列/对象，我们试用复杂类型来储存从原始表中抠出来的有用的部分，同时不会对原始数据造成变动。同样，我们也可以使用
  //复杂类型来储存多个表的结合，想干嘛就干嘛。

//Q: 如何自定义建立一个复杂类型来储存函数的返回值？
//A: 同样在编辑函数导入对话框，点击Get Column Information即可获得所有该函数的返回列，然后再返回类型选择Complex，编辑爱的名称，点击Update即可生成一个
  //新的复杂类型。可以通过Model浏览器查看这个复杂类型，并可以展开其所有属性。我们可以随意删除其中的属性直到满意/符合项目要求为止。

//暂时想到这么多，最后更新2017/12/18
